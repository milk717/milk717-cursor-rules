---
alwaysApply: true
---

# React 컴포넌트 Hook 선언 순서 규칙

React 함수 컴포넌트 내에서 Hook과 변수를 선언할 때는 다음 순서를 따릅니다.

## 선언 순서

```typescript
/**
 * React 컴포넌트 Hook 선언 순서
 * 
 * 0. Props 구조분해할당
 * 1. Router Hooks (useParams, useRouter, useNavigate, useMatch, useLocation, useSearchParams)
 * 2. Context Hooks (useContext, useTheme, useQueryClient 등 Provider에서 제공되는 값)
 * 3. Global Store (Zustand, Redux 등 전역 상태 관리)
 * 4. Server State (useQuery, useMutation, useMutationState 등 React Query)
 * 5. Custom Hooks (라이브러리 훅, 자체 제작 훅)
 *    - useForm, useFormik 등 Form 관련 훅 포함
 *    - Hook 선언과 동시에 구조분해하는 것을 권장
 * 6. Local State (useState, useReducer)
 * 7. Refs (useRef)
 * 8. 파생 상태 (useMemo, 계산된 const 값, Hook 반환값의 지연 구조분해)
 * 9. Effects (useEffect, useLayoutEffect)
 * 10. Event Handlers & Callbacks (useCallback, 일반 함수 형태의 이벤트 핸들러)
 */
```

## 예시

```typescript
function MyComponent({ userId, onSubmit, initialData }: MyComponentProps) {
  // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━
  // 0. Props 구조분해할당
  // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━
  const { name, email } = initialData;
  
  // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━
  // 1. Router
  // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━
  const router = useRouter();
  const { chat_id } = useParams();
  const navigate = useNavigate();
  const location = useLocation();
  
  // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━
  // 2. Context
  // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━
  const { theme } = useTheme();
  const { t } = useTranslation();
  const queryClient = useQueryClient();
  const { scrollToBottom } = useScrollContext();
  
  // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━
  // 3. Global Store
  // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━
  const messages = useChatStore(state => state.messages);
  const { saveChatInput } = useChatStore();
  const count = useCountStore(state => state.count);
  
  // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━
  // 4. Server State
  // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━
  const { data: chat } = useQuery({ queryKey: ['chat', chat_id], ... });
  const mutation = useMutation({ mutationFn: sendMessage });
  const mutationState = useMutationState({ filters: { status: 'pending' } });
  
  // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━
  // 5. Custom Hooks
  // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━
  const { handleSubmit, reset, control, formState } = useForm({
    defaultValues: { text: '' }
  });
  const { files, addFiles } = useChatFileUpload({ maxFiles: 5 });
  const { subject } = useSubject();
  const animation = useAnimation();
  
  // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━
  // 6. Local State
  // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━
  const [isOpen, setIsOpen] = useState(false);
  const [text, setText] = useState('');
  const [selectedId, setSelectedId] = useState<number | null>(null);
  
  // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━
  // 7. Refs
  // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━
  const inputRef = useRef<HTMLInputElement>(null);
  const previousValueRef = useRef(count);
  
  // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━
  // 8. 파생 상태
  // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━
  const { isSubmitting, errors } = formState;
  const hasFiles = files.length > 0;
  const fullName = `${name} (${email})`;
  const isValid = useMemo(() => {
    return text.trim().length > 0 || hasFiles;
  }, [text, hasFiles]);
  
  // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━
  // 9. Effects
  // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━
  useEffect(() => {
    console.log('Component mounted');
  }, []);
  
  useEffect(() => {
    if (chat_id) {
      scrollToBottom();
    }
  }, [chat_id, scrollToBottom]);
  
  // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━
  // 10. Event Handlers & Callbacks
  // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━
  const handleChange = (e: ChangeEvent<HTMLInputElement>) => {
    setText(e.target.value);
  };
  
  const handleClick = useCallback(() => {
    if (!isValid) return;
    onSubmit(userId);
  }, [isValid, onSubmit, userId]);
  
  const handleReset = useCallback(() => {
    reset();
    setText('');
  }, [reset]);
  
  return (
    <div>
      {/* JSX */}
    </div>
  );
}
```

## 핵심 원칙

1. **환경 → 데이터 → 로직** 순서로 흐름이 자연스럽게 이어짐
2. **의존성 방향**: 위에서 선언된 것을 아래서 사용 (역방향 의존성 없음)
3. **Props는 가장 먼저**: 외부에서 주입되는 데이터이므로 최우선
4. **Context는 기술적으로 정확하게**: `useQueryClient()`는 Context이므로 2번에 배치
5. **Form Hook은 Custom Hook**: `useForm` 등은 5번 섹션에 배치하고, 선언과 동시에 구조분해 권장
6. **Effects는 사이드 이펙트**: 컴포넌트 로직의 부가적인 부분이므로 이벤트 핸들러 전에 배치
7. **Event Handlers는 JSX와 가까이**: return 문 바로 위에 위치하여 가독성 향상

## 예외 상황

- **의존성이 있는 경우**: 순서를 조정 가능 (예: state를 hook에 주입해야 하는 경우)
- **일관성이 최우선**: 어떤 순서든 프로젝트 전체에서 일관되게 유지

## 구조분해할당 팁

```typescript
// ✅ 권장: Hook 선언과 동시에 구조분해
const { handleSubmit, reset, formState } = useForm({...});

// ⚠️ 허용: 바로 아래 구조 분해
const form = useForm({...});
const { handleSubmit, reset } = form;

// ❌ 지양: Hook과 구조분해 사이에 무관한 코드
const form = useForm({...});
const [isOpen, setIsOpen] = useState(false);  // 다른 state
const { handleSubmit } = form;  // 흐름이 끊김
```

## 카테고리별 상세 가이드

### 1. Router Hooks
- 라우터 인스턴스 (useRouter) → 위치 정보 (useLocation, useParams) → 네비게이션 (useNavigate) 순서 권장
- 모든 라우터 관련 훅을 함께 그룹핑

### 2. Context Hooks
- UI Context (theme, i18n) → Data Context (queryClient) 순서
- Context는 환경 설정을 제공하므로 가장 앞쪽에 배치

### 3. Global Store
- Zustand의 경우 selector 사용 시 useShallow 활용 권장
- 관련 있는 store들끼리 그룹핑

### 4. Server State
- Query → Mutation → MutationState 순서
- 같은 도메인의 쿼리들을 함께 그룹핑

### 5. Custom Hooks
- 라이브러리 훅 (useForm, useAnimation 등)
- 프로젝트 자체 제작 훅
- Hook 선언과 동시에 필요한 값만 구조분해하는 것을 권장

### 6. Local State
- 단순한 boolean, string, number 상태
- 복잡한 상태는 useReducer 고려

### 7. Refs
- DOM 참조용 ref
- 이전 값 저장용 ref
- 렌더링에 영향을 주지 않는 값 저장

### 8. 파생 상태
- Hook 반환값의 추가 구조분해
- 단순 계산된 const 값
- useMemo로 메모이제이션된 값

### 9. Effects
- 마운트/언마운트 관련 effect를 먼저
- 의존성이 있는 effect를 나중에
- cleanup 함수가 필요한 경우 반드시 포함

### 10. Event Handlers
- 일반 함수 형태와 useCallback 형태 모두 이 섹션에 배치
- 복잡한 로직은 별도 함수로 추출 고려
- JSX와 가까이 배치하여 가독성 향상
